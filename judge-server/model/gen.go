// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model

import (
	"context"
	"database/sql"

	"gorm.io/gorm"

	"gorm.io/gen"

	"gorm.io/plugin/dbresolver"
)

func Use(db *gorm.DB, opts ...gen.DOOption) *Query {
	return &Query{
		db:                 db,
		Cache:              newCache(db, opts...),
		CacheLock:          newCacheLock(db, opts...),
		FailedJob:          newFailedJob(db, opts...),
		Job:                newJob(db, opts...),
		JobBatch:           newJobBatch(db, opts...),
		Migration:          newMigration(db, opts...),
		PasswordResetToken: newPasswordResetToken(db, opts...),
		Problem:            newProblem(db, opts...),
		Session:            newSession(db, opts...),
		Submission:         newSubmission(db, opts...),
		SubmissionTestcase: newSubmissionTestcase(db, opts...),
		User:               newUser(db, opts...),
	}
}

type Query struct {
	db *gorm.DB

	Cache              cache
	CacheLock          cacheLock
	FailedJob          failedJob
	Job                job
	JobBatch           jobBatch
	Migration          migration
	PasswordResetToken passwordResetToken
	Problem            problem
	Session            session
	Submission         submission
	SubmissionTestcase submissionTestcase
	User               user
}

func (q *Query) Available() bool { return q.db != nil }

func (q *Query) clone(db *gorm.DB) *Query {
	return &Query{
		db:                 db,
		Cache:              q.Cache.clone(db),
		CacheLock:          q.CacheLock.clone(db),
		FailedJob:          q.FailedJob.clone(db),
		Job:                q.Job.clone(db),
		JobBatch:           q.JobBatch.clone(db),
		Migration:          q.Migration.clone(db),
		PasswordResetToken: q.PasswordResetToken.clone(db),
		Problem:            q.Problem.clone(db),
		Session:            q.Session.clone(db),
		Submission:         q.Submission.clone(db),
		SubmissionTestcase: q.SubmissionTestcase.clone(db),
		User:               q.User.clone(db),
	}
}

func (q *Query) ReadDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Read))
}

func (q *Query) WriteDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Write))
}

func (q *Query) ReplaceDB(db *gorm.DB) *Query {
	return &Query{
		db:                 db,
		Cache:              q.Cache.replaceDB(db),
		CacheLock:          q.CacheLock.replaceDB(db),
		FailedJob:          q.FailedJob.replaceDB(db),
		Job:                q.Job.replaceDB(db),
		JobBatch:           q.JobBatch.replaceDB(db),
		Migration:          q.Migration.replaceDB(db),
		PasswordResetToken: q.PasswordResetToken.replaceDB(db),
		Problem:            q.Problem.replaceDB(db),
		Session:            q.Session.replaceDB(db),
		Submission:         q.Submission.replaceDB(db),
		SubmissionTestcase: q.SubmissionTestcase.replaceDB(db),
		User:               q.User.replaceDB(db),
	}
}

type queryCtx struct {
	Cache              *cacheDo
	CacheLock          *cacheLockDo
	FailedJob          *failedJobDo
	Job                *jobDo
	JobBatch           *jobBatchDo
	Migration          *migrationDo
	PasswordResetToken *passwordResetTokenDo
	Problem            *problemDo
	Session            *sessionDo
	Submission         *submissionDo
	SubmissionTestcase *submissionTestcaseDo
	User               *userDo
}

func (q *Query) WithContext(ctx context.Context) *queryCtx {
	return &queryCtx{
		Cache:              q.Cache.WithContext(ctx),
		CacheLock:          q.CacheLock.WithContext(ctx),
		FailedJob:          q.FailedJob.WithContext(ctx),
		Job:                q.Job.WithContext(ctx),
		JobBatch:           q.JobBatch.WithContext(ctx),
		Migration:          q.Migration.WithContext(ctx),
		PasswordResetToken: q.PasswordResetToken.WithContext(ctx),
		Problem:            q.Problem.WithContext(ctx),
		Session:            q.Session.WithContext(ctx),
		Submission:         q.Submission.WithContext(ctx),
		SubmissionTestcase: q.SubmissionTestcase.WithContext(ctx),
		User:               q.User.WithContext(ctx),
	}
}

func (q *Query) Transaction(fc func(tx *Query) error, opts ...*sql.TxOptions) error {
	return q.db.Transaction(func(tx *gorm.DB) error { return fc(q.clone(tx)) }, opts...)
}

func (q *Query) Begin(opts ...*sql.TxOptions) *QueryTx {
	tx := q.db.Begin(opts...)
	return &QueryTx{Query: q.clone(tx), Error: tx.Error}
}

type QueryTx struct {
	*Query
	Error error
}

func (q *QueryTx) Commit() error {
	return q.db.Commit().Error
}

func (q *QueryTx) Rollback() error {
	return q.db.Rollback().Error
}

func (q *QueryTx) SavePoint(name string) error {
	return q.db.SavePoint(name).Error
}

func (q *QueryTx) RollbackTo(name string) error {
	return q.db.RollbackTo(name).Error
}
